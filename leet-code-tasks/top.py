Важный момент: словарь h обновляется после проверки, а не до
Рассмотрим шаги подробнее
Изначально:
Перед обходом дерева словарь h пуст: {}.

Мы начинаем обход с currSum = 0 (сумма до корня).

Шаг 1: в корне (значение 10)
currSum = 0 + 10 = 10

Проверяем:

currSum == 8? Нет.

currSum - 8 = 2 есть в h? Нет, потому что h пуст.

Теперь после проверок добавляем текущую сумму в словарь:

h = 1

Словарь: {10: 1}

Шаг 2: узел 5 (левый ребёнок корня)
currSum = 10 + 5 = 15

Проверяем:

currSum == 8? Нет.

currSum - 8 = 7 есть в h? Нет, в словаре {10: 1} нет ключа 7.

Добавляем в словарь:

h = 1

Словарь: {10: 1, 15: 1}

Шаг 3: узел 3 (левый ребёнок 5)
currSum = 15 + 3 = 18

Проверяем:

currSum == 8? Нет.

currSum - 8 = 10 есть в h? Да! В словаре есть ключ 10 с значением 1.

Значит существует путь с суммой 8 между узлом с префиксной суммой 10 (корень) и текущим узлом 3.

Увеличиваем счётчик путей на 1.

Добавляем текущую сумму в словарь:

h = 1

Словарь: {10: 1, 15: 1, 18: 1}

Ответ на ваш вопрос
Значит в объекте у нас 2 лежит?

Нет, в словаре не лежит ключ 2.
На шаге 3 мы проверяем, есть ли ключ currSum - t = 18 - 8 = 10 — и он есть! Значит путь с суммой 8 существует.

Почему не было ключа 2?
Потому что ключи в словаре — это префиксные суммы, которые мы встречали на пути от корня до текущего узла. На момент шага 3 префиксная сумма 2 не встречалась, поэтому в словаре её нет.

Итог
Ключи в словаре — это именно префиксные суммы, а не просто разности.

Мы ищем в словаре currSum - t, чтобы узнать, встречалась ли сумма, которая позволит получить путь с суммой t.

В вашем примере на шаге 3 это 10, а не 2.
